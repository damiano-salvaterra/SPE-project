from typing import List, Dict, Optional

# Core Engine Components
from simulator.engine.Scheduler import Scheduler
from simulator.engine.RandomManager import RandomManager
from simulator.engine.common.SimulationContext import SimulationContext

# Environment and Propagation
from simulator.environment.geometry import DSpace, CartesianCoordinate
from simulator.environment.propagation.narrowband import NarrowbandChannelModel
from simulator.entities.physical.media.WirelessChannel import WirelessChannel

# Simulation Entities
from simulator.entities.physical.devices.nodes import StaticNode
from simulator.entities.common.Entity import Entity
from simulator.engine.common.Monitor import Monitor

# Application Layer (for node creation)
from simulator.applications.Application import Application


class Kernel:
    '''
    The main simulation kernel.
    This class provides a high-level API to bootstrap, configure, run,
    and monitor the discrete-event simulation. It encapsulates all the core
    components and the simulation state.
    '''

    def __init__(self, root_seed = 0):
        '''Init the kernel and its core components.'''
        self.context = SimulationContext(scheduler= Scheduler(), random_manager= RandomManager(root_seed=root_seed))
        self.nodes: Dict[str, StaticNode] = {}
        self.channel: Optional[WirelessChannel] = None
        self.dspace: Optional[DSpace] = None
        self.propagation_model: Optional[NarrowbandChannelModel] = None
        self._is_bootstrapped = False

    def bootstrap(
        self,
        seed: int,
        dspace_step: int,
        dspace_npt: int,
        freq: float,
        filter_bandwidth: float,
        coh_d: float,
        shadow_dev: float,
        pl_exponent: float,
        d0: float,
        fading_shape: float
    ):
        """
        Initializes and configures the entire simulation environment with explicit parameters.

        This must be called before adding nodes or running the simulation.

        Args:
            seed (int): The root seed for the random number generator.
            dspace_step (int): The step size (resolution) of the discrete space grid.
            dspace_npt (int): The number of points per dimension for the grid.
            freq (float): The carrier frequency in Hz.
            filter_bandwidth (float): The receiver filter bandwidth in Hz.
            coh_d (float): The coherence distance for the shadowing model in meters.
            shadow_dev (float): The standard deviation of the shadowing in dB.
            pl_exponent (float): The path loss exponent.
            d0 (float): The reference distance for the path loss model in meters.
            fading_shape (float): The shape parameter (m) for the Nakagami-m fading model.
        """
        # Initialize core components
        self.context.random_manager.reset(new_root_seed=seed)
        self.context.scheduler.flush()

        # Create the physical environment
        self.dspace = DSpace(
            dspace_step=dspace_step,
            dspace_npt=dspace_npt
        )

        self.propagation_model = NarrowbandChannelModel(
            random_manager=self.context.random_manager,
            dspace=self.dspace,
            freq=freq,
            filter_bandwidth=filter_bandwidth,
            coh_d=coh_d,
            shadow_dev=shadow_dev,
            pl_exponent=pl_exponent,
            d0=d0,
            fading_shape=fading_shape
        )
        
        # Generate the shadowing map, a one-time operation for the environment
        self.propagation_model.generate_shadowing_map()

        # Create the communication channel entity
        self.channel = WirelessChannel(
            propagation_model=self.propagation_model,
            nodes=[], # Nodes will be added later
            context=self.context
        )

        self._is_bootstrapped = True
        print("Kernel bootstrapped successfully.")

    def set_parameters(self, **kwargs): #TODO: generated by copilot, it has to be changed
        '''
        Allows setting or updating simulation parameters after bootstrap.
        Note: Some parameters (like seed or dspace) require a full re-bootstrap.
        '''
        # This is a placeholder. A real implementation would have logic
        # to update specific parameters on-the-fly if possible.
        print(f"Setting parameters: {kwargs}. Note: a re-bootstrap may be needed for some changes.")

    def add_node(self, node_id: str, position: CartesianCoordinate, app: Application, linkaddr: bytes) -> Optional[StaticNode]:
        '''
        Adds a new node to the simulation.

        Args:
            node_id: A unique string identifier for the node.
            position: The CartesianCoordinate of the node.
            app: An instance of the Application layer for this node.
            linkaddr: The 2-byte link layer address for the node.

        Returns:
            The created StaticNode object, or None if bootstrap hasn't been run.
        '''
        if not self._is_bootstrapped:
            print("Error: Kernel must be bootstrapped before adding nodes.")
            return None
        if node_id in self.nodes:
            print(f"Error: Node with ID '{node_id}' already exists.")
            return None

        node = StaticNode(
            node_id=node_id,
            linkaddr=linkaddr,
            position=position,
            application=app,
            context=self.context
        )
        
        # Add node to the kernel's list and the channel's list
        self.nodes[node_id] = node
        self.channel.nodes.append(node)
        
        # Link the PHY layer of the node to the channel
        node.phy.connect_transmission_media(self.channel)
        
        print(f"Node '{node_id}' added at position ({position.x}, {position.y}).")
        return node


    def remove_node(self, node_id: str):
        '''Removes a node from the simulation.'''
        if node_id not in self.nodes:
            print(f"Error: Node with ID '{node_id}' not found.")
            return

        node_to_remove = self.nodes[node_id]
        self.channel.nodes.remove(node_to_remove)
        del self.nodes[node_id]
        print(f"Node '{node_id}' removed.")



    def step(self):
        '''Executes the next single event in the simulation queue.'''
        if not self.context.scheduler.is_empty():
            self.context.scheduler.run_next_event()


    def run_n_steps(self, n: int):
        '''Executes a specified number of simulation events.'''
        for _ in range(n):
            if self.context.scheduler.is_empty():
                print("Simulation finished: event queue is empty.")
                break
            self.step()

    def run(self, until: float = float('inf')):
        '''
        Runs the simulation until the event queue is empty or a stop condition is met.

        Args:
            until (float): The simulation time at which to stop. Defaults to infinity.
        '''
        print(f"Running simulation until time {until} or event queue is empty...")
        while not self.context.scheduler.is_empty() and self.context.scheduler.now() <= until:
            self.step()
        print(f"Simulation stopped at time: {self.context.scheduler.now()}")



    def get_entity(self, entity_path: str) -> Optional[Entity]:
        '''
        Retrieves an entity (Node or a specific layer) using a path string.
        Example paths: "node_1", "node_1.mac", "channel".
        '''
        parts = entity_path.split('.')
        if parts[0] == "channel":
            return self.channel
            
        node = self.nodes.get(parts[0])
        if not node:
            print(f"Error: Node '{parts[0]}' not found.")
            return None
        
        if len(parts) == 1:
            return node
        
        # Access sub-entities like layers
        entity = getattr(node, parts[1], None)
        if not isinstance(entity, Entity):
            print(f"Error: Attribute '{parts[1]}' of node '{parts[0]}' is not a valid Entity.")
            return None
            
        return entity
    


    def attach_monitor(self, monitor: Monitor, entity_path: str):
        '''
        Attaches a monitor to a specified entity in the simulation.

        Args:
            monitor: The Monitor instance to attach.
            entity_path: A string path to the entity (e.g., "node_1.mac").
        '''
        entity = self.get_entity(entity_path)
        if entity:
            entity.attach_monitor(monitor)
            print(f"Monitor '{type(monitor).__name__}' attached to '{entity_path}'.")



    def detach_monitor(self, monitor: Monitor, entity_path: str):
        '''Detaches a monitor from a specified entity.'''
        entity = self.get_entity(entity_path)
        if entity:
            entity.detach_monitor(monitor)
            print(f"Monitor '{type(monitor).__name__}' detached from '{entity_path}'.")
